<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Code Formation: Coupled Oscillators</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #000;
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 20px;
      padding: 12px 16px;
      background: #0a0a0a;
      border-bottom: 1px solid #1a1a1a;
      flex-wrap: wrap;
    }

    .slider-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .slider-label {
      font-size: 9px;
      color: #555;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .slider-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    input[type="range"] {
      width: 80px;
      height: 3px;
      -webkit-appearance: none;
      background: #333;
      border-radius: 2px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: #fff;
      border-radius: 50%;
      cursor: pointer;
    }
    .slider-val {
      font-family: monospace;
      font-size: 11px;
      color: #22c55e;
      min-width: 30px;
    }

    .btn {
      padding: 8px 16px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 4px;
      color: #888;
      font-size: 11px;
      cursor: pointer;
    }
    .btn:hover { background: #222; color: #fff; }
    .btn.active { background: #22c55e; color: #000; border-color: #22c55e; }

    .meters {
      display: flex;
      gap: 20px;
      margin-left: auto;
      padding: 8px 12px;
      background: #111;
      border-radius: 4px;
    }
    .meter {
      text-align: center;
    }
    .meter-label {
      font-size: 8px;
      color: #555;
      text-transform: uppercase;
    }
    .meter-value {
      font-family: monospace;
      font-size: 16px;
      font-weight: bold;
    }

    .main {
      flex: 1;
      display: flex;
      position: relative;
    }
    canvas { width: 100%; height: 100%; }

    .legend {
      position: absolute;
      bottom: 12px;
      left: 12px;
      font-size: 10px;
      color: #444;
      line-height: 1.6;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .legend-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }
  </style>
</head>
<body>
  <div class="controls">
    <div class="slider-group">
      <span class="slider-label">Code Bandwidth (k modes)</span>
      <div class="slider-row">
        <input type="range" id="bandwidth" min="1" max="16" step="1" value="8">
        <span class="slider-val" id="bw-val">8</span>
      </div>
    </div>

    <div class="slider-group">
      <span class="slider-label">Coupling</span>
      <div class="slider-row">
        <input type="range" id="coupling" min="0" max="2" step="0.1" value="1">
        <span class="slider-val" id="coupling-val">1.0</span>
      </div>
    </div>

    <div class="slider-group">
      <span class="slider-label">Control</span>
      <div class="slider-row">
        <input type="range" id="control" min="0" max="2" step="0.1" value="0.5">
        <span class="slider-val" id="control-val">0.5</span>
      </div>
    </div>

    <div class="slider-group">
      <span class="slider-label">Noise</span>
      <div class="slider-row">
        <input type="range" id="noise" min="0" max="1" step="0.05" value="0.2">
        <span class="slider-val" id="noise-val">0.2</span>
      </div>
    </div>

    <button class="btn" id="shock-btn">Shock A</button>
    <button class="btn" id="demo-btn">Demo</button>

    <div class="meters">
      <div class="meter">
        <div class="meter-label">A Complexity</div>
        <div class="meter-value" id="complexity-a" style="color: #3b82f6">0.0</div>
      </div>
      <div class="meter">
        <div class="meter-label">B Complexity</div>
        <div class="meter-value" id="complexity-b" style="color: #ef4444">0.0</div>
      </div>
      <div class="meter">
        <div class="meter-label">Mismatch</div>
        <div class="meter-value" id="mismatch" style="color: #f59e0b">0.0</div>
      </div>
    </div>
  </div>

  <div class="main">
    <canvas id="canvas"></canvas>
    <div class="legend">
      <div class="legend-item"><div class="legend-dot" style="background: #3b82f6"></div> System A (world) - evolves freely</div>
      <div class="legend-item"><div class="legend-dot" style="background: #ef4444"></div> System B (observer) - sees only k modes</div>
      <div class="legend-item"><div class="legend-dot" style="background: #22c55e"></div> Code: Fourier modes 1..k</div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    function resize() {
      canvas.width = canvas.clientWidth * devicePixelRatio;
      canvas.height = canvas.clientHeight * devicePixelRatio;
      ctx.scale(devicePixelRatio, devicePixelRatio);
    }
    resize();
    window.addEventListener('resize', resize);

    // Parameters
    const N = 32; // oscillators per ring
    let k = 8;    // code bandwidth (modes 1..k)
    let K = 1.0;  // internal coupling
    let lambda = 0.5; // control strength (B trying to match A)
    let sigma = 0.2;  // noise

    // State: phases in [-pi, pi]
    const thetaA = new Float32Array(N);
    const thetaB = new Float32Array(N);
    const omegaA = new Float32Array(N); // natural frequencies
    const omegaB = new Float32Array(N);

    function init() {
      for (let i = 0; i < N; i++) {
        thetaA[i] = (Math.random() - 0.5) * Math.PI * 2;
        thetaB[i] = (Math.random() - 0.5) * Math.PI * 2;
        // Slight frequency spread
        omegaA[i] = 0.05 + (Math.random() - 0.5) * 0.02;
        omegaB[i] = 0.05 + (Math.random() - 0.5) * 0.02;
      }
    }
    init();

    // Gaussian noise (Box-Muller)
    function randn() {
      const u1 = Math.random(), u2 = Math.random();
      return Math.sqrt(-2 * Math.log(u1 + 1e-10)) * Math.cos(2 * Math.PI * u2);
    }

    // Compute Fourier coefficients (complex)
    // C_m = (1/N) * sum_i exp(i*theta_i) * exp(-i*2*pi*m*i/N)
    function fourierCoeffs(theta, maxM) {
      const coeffs = [];
      for (let m = 0; m <= maxM; m++) {
        let re = 0, im = 0;
        for (let i = 0; i < N; i++) {
          const phase = theta[i] - 2 * Math.PI * m * i / N;
          re += Math.cos(phase);
          im += Math.sin(phase);
        }
        coeffs.push({ re: re / N, im: im / N });
      }
      return coeffs;
    }

    // Reconstruct low-pass filtered phase field from k modes
    function reconstruct(coeffs, k) {
      const recon = new Float32Array(N);
      for (let i = 0; i < N; i++) {
        let zRe = 0, zIm = 0;
        for (let m = 0; m <= k; m++) {
          const phase = 2 * Math.PI * m * i / N;
          // Add mode m
          zRe += coeffs[m].re * Math.cos(phase) - coeffs[m].im * Math.sin(phase);
          zIm += coeffs[m].re * Math.sin(phase) + coeffs[m].im * Math.cos(phase);
          // Add mode -m (conjugate) for m > 0
          if (m > 0) {
            zRe += coeffs[m].re * Math.cos(-phase) - (-coeffs[m].im) * Math.sin(-phase);
            zIm += coeffs[m].re * Math.sin(-phase) + (-coeffs[m].im) * Math.cos(-phase);
          }
        }
        recon[i] = Math.atan2(zIm, zRe);
      }
      return recon;
    }

    // Spectral entropy -> effective number of modes
    function spectralComplexity(coeffs, maxM) {
      const amps = [];
      let sum = 0;
      for (let m = 1; m <= maxM; m++) {
        const amp = Math.sqrt(coeffs[m].re ** 2 + coeffs[m].im ** 2);
        amps.push(amp);
        sum += amp;
      }
      if (sum < 1e-10) return 1;

      let entropy = 0;
      for (const a of amps) {
        const p = a / sum;
        if (p > 1e-10) entropy -= p * Math.log(p);
      }
      return Math.exp(entropy);
    }

    // Step dynamics
    const dt = 0.3;

    function step() {
      // Compute code from A
      const coeffsA = fourierCoeffs(thetaA, 16);
      const targetPhase = reconstruct(coeffsA, k);

      // Update A (free Kuramoto + noise)
      for (let i = 0; i < N; i++) {
        let coupling = 0;
        const iLeft = (i - 1 + N) % N;
        const iRight = (i + 1) % N;
        coupling += Math.sin(thetaA[iLeft] - thetaA[i]);
        coupling += Math.sin(thetaA[iRight] - thetaA[i]);

        thetaA[i] += dt * (omegaA[i] + K * coupling) + sigma * randn() * Math.sqrt(dt);
      }

      // Update B (Kuramoto + control toward code)
      for (let i = 0; i < N; i++) {
        let coupling = 0;
        const iLeft = (i - 1 + N) % N;
        const iRight = (i + 1) % N;
        coupling += Math.sin(thetaB[iLeft] - thetaB[i]);
        coupling += Math.sin(thetaB[iRight] - thetaB[i]);

        // Control: nudge toward target (low-pass A)
        const control = lambda * Math.sin(targetPhase[i] - thetaB[i]);

        thetaB[i] += dt * (omegaB[i] + K * coupling + control) + sigma * 0.5 * randn() * Math.sqrt(dt);
      }

      // Wrap to [-pi, pi]
      for (let i = 0; i < N; i++) {
        thetaA[i] = ((thetaA[i] + Math.PI) % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI) - Math.PI;
        thetaB[i] = ((thetaB[i] + Math.PI) % (2 * Math.PI) + 2 * Math.PI) % (2 * Math.PI) - Math.PI;
      }

      return { coeffsA, targetPhase };
    }

    // Phase to color (HSV wheel)
    function phaseToColor(phase, alpha = 1) {
      const hue = ((phase + Math.PI) / (2 * Math.PI)) * 360;
      return `hsla(${hue}, 70%, 55%, ${alpha})`;
    }

    // Draw ring
    function drawRing(cx, cy, radius, theta, baseHue, label) {
      // Ring outline
      ctx.strokeStyle = '#222';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.stroke();

      // Oscillators
      for (let i = 0; i < N; i++) {
        const angle = (i / N) * Math.PI * 2 - Math.PI / 2;
        const x = cx + Math.cos(angle) * radius;
        const y = cy + Math.sin(angle) * radius;

        ctx.fillStyle = phaseToColor(theta[i]);
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI * 2);
        ctx.fill();
      }

      // Label
      ctx.fillStyle = '#444';
      ctx.font = '11px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText(label, cx, cy);
    }

    // Draw mode bar chart
    function drawModes(cx, cy, width, height, coeffsA, coeffsB, maxK) {
      const barWidth = width / (maxK + 1);

      ctx.fillStyle = '#111';
      ctx.fillRect(cx - width/2, cy - height/2, width, height);
      ctx.strokeStyle = '#222';
      ctx.strokeRect(cx - width/2, cy - height/2, width, height);

      // Find max amplitude for scaling
      let maxAmp = 0.01;
      for (let m = 0; m <= maxK; m++) {
        maxAmp = Math.max(maxAmp, Math.sqrt(coeffsA[m].re**2 + coeffsA[m].im**2));
        maxAmp = Math.max(maxAmp, Math.sqrt(coeffsB[m].re**2 + coeffsB[m].im**2));
      }

      for (let m = 0; m <= maxK; m++) {
        const x = cx - width/2 + m * barWidth + barWidth * 0.1;

        // A bars (blue)
        const ampA = Math.sqrt(coeffsA[m].re**2 + coeffsA[m].im**2);
        const hA = (ampA / maxAmp) * (height - 10);
        ctx.fillStyle = m <= k ? '#3b82f6' : '#1e3a5f';
        ctx.fillRect(x, cy + height/2 - 5 - hA, barWidth * 0.35, hA);

        // B bars (red)
        const ampB = Math.sqrt(coeffsB[m].re**2 + coeffsB[m].im**2);
        const hB = (ampB / maxAmp) * (height - 10);
        ctx.fillStyle = m <= k ? '#ef4444' : '#5f1e1e';
        ctx.fillRect(x + barWidth * 0.45, cy + height/2 - 5 - hB, barWidth * 0.35, hB);

        // Mode number
        if (m <= k) {
          ctx.fillStyle = '#22c55e';
        } else {
          ctx.fillStyle = '#333';
        }
        ctx.font = '8px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(m.toString(), x + barWidth * 0.4, cy + height/2 + 8);
      }

      // Bandwidth marker
      const kX = cx - width/2 + (k + 1) * barWidth;
      ctx.strokeStyle = '#22c55e';
      ctx.lineWidth = 2;
      ctx.setLineDash([3, 3]);
      ctx.beginPath();
      ctx.moveTo(kX, cy - height/2);
      ctx.lineTo(kX, cy + height/2);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.fillStyle = '#22c55e';
      ctx.font = '9px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText('â† code', kX + 4, cy - height/2 + 12);
    }

    // Draw mismatch lines between rings
    function drawMismatch(cxA, cyA, cxB, cyB, radius, thetaA, thetaB) {
      for (let i = 0; i < N; i++) {
        const mismatch = Math.abs(thetaA[i] - thetaB[i]);
        if (mismatch > 0.5) {
          const angle = (i / N) * Math.PI * 2 - Math.PI / 2;
          const xA = cxA + Math.cos(angle) * radius;
          const yA = cyA + Math.sin(angle) * radius;
          const xB = cxB + Math.cos(angle) * radius;
          const yB = cyB + Math.sin(angle) * radius;

          ctx.strokeStyle = `rgba(245, 158, 11, ${Math.min(1, mismatch / 2)})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(xA, yA);
          ctx.lineTo(xB, yB);
          ctx.stroke();
        }
      }
    }

    // Main render
    function render() {
      const W = canvas.clientWidth;
      const H = canvas.clientHeight;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      const { coeffsA, targetPhase } = step();
      const coeffsB = fourierCoeffs(thetaB, 16);

      // Layout
      const ringRadius = Math.min(W, H) * 0.15;
      const cxA = W * 0.25;
      const cxB = W * 0.75;
      const cyRings = H * 0.4;

      // Draw mismatch lines first (behind rings)
      drawMismatch(cxA, cyRings, cxB, cyRings, ringRadius, thetaA, thetaB);

      // Draw rings
      drawRing(cxA, cyRings, ringRadius, thetaA, 220, 'A (world)');
      drawRing(cxB, cyRings, ringRadius, thetaB, 0, 'B (observer)');

      // Draw mode chart
      const modeWidth = W * 0.5;
      const modeHeight = H * 0.2;
      drawModes(W * 0.5, H * 0.78, modeWidth, modeHeight, coeffsA, coeffsB, 16);

      // Update meters
      const complexityA = spectralComplexity(coeffsA, 16);
      const complexityB = spectralComplexity(coeffsB, 16);

      let totalMismatch = 0;
      for (let i = 0; i < N; i++) {
        totalMismatch += Math.abs(Math.sin((thetaA[i] - thetaB[i]) / 2));
      }
      totalMismatch /= N;

      document.getElementById('complexity-a').textContent = complexityA.toFixed(1);
      document.getElementById('complexity-b').textContent = complexityB.toFixed(1);
      document.getElementById('mismatch').textContent = totalMismatch.toFixed(2);

      requestAnimationFrame(render);
    }

    // Shock: inject high-frequency pattern into A
    function shockA() {
      for (let i = 0; i < N; i++) {
        // Add a high-frequency perturbation (mode 8-12)
        thetaA[i] += 1.5 * Math.sin(8 * 2 * Math.PI * i / N);
        thetaA[i] += 1.0 * Math.sin(10 * 2 * Math.PI * i / N);
      }
    }

    // Demo sequence
    let demoRunning = false;
    async function runDemo() {
      if (demoRunning) return;
      demoRunning = true;
      document.getElementById('demo-btn').classList.add('active');

      const bwSlider = document.getElementById('bandwidth');

      // Step 1: High bandwidth
      bwSlider.value = 12;
      k = 12;
      document.getElementById('bw-val').textContent = '12';
      await sleep(3000);

      // Step 2: Gradually reduce
      for (let v = 12; v >= 2; v--) {
        bwSlider.value = v;
        k = v;
        document.getElementById('bw-val').textContent = v.toString();
        await sleep(400);
      }
      await sleep(2000);

      // Step 3: Shock
      shockA();
      await sleep(3000);

      // Step 4: Restore
      for (let v = 2; v <= 8; v++) {
        bwSlider.value = v;
        k = v;
        document.getElementById('bw-val').textContent = v.toString();
        await sleep(300);
      }

      demoRunning = false;
      document.getElementById('demo-btn').classList.remove('active');
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Controls
    document.getElementById('bandwidth').addEventListener('input', e => {
      k = parseInt(e.target.value);
      document.getElementById('bw-val').textContent = k.toString();
    });

    document.getElementById('coupling').addEventListener('input', e => {
      K = parseFloat(e.target.value);
      document.getElementById('coupling-val').textContent = K.toFixed(1);
    });

    document.getElementById('control').addEventListener('input', e => {
      lambda = parseFloat(e.target.value);
      document.getElementById('control-val').textContent = lambda.toFixed(1);
    });

    document.getElementById('noise').addEventListener('input', e => {
      sigma = parseFloat(e.target.value);
      document.getElementById('noise-val').textContent = sigma.toFixed(2);
    });

    document.getElementById('shock-btn').addEventListener('click', shockA);
    document.getElementById('demo-btn').addEventListener('click', runDemo);

    // Start
    render();
  </script>
</body>
</html>
