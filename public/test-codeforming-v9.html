<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Code Formation v9</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #000;
      color: #e0e0e0;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Top control bar */
    .controls {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 12px 16px;
      background: #0a0a0a;
      border-bottom: 1px solid #1a1a1a;
      flex-wrap: wrap;
    }

    .mode-btns {
      display: flex;
      gap: 6px;
    }

    .mode-btn {
      padding: 6px 12px;
      background: #111;
      border: 1px solid #222;
      border-radius: 4px;
      color: #666;
      font-size: 11px;
      cursor: pointer;
    }
    .mode-btn:hover { background: #1a1a1a; color: #888; }
    .mode-btn.active { background: #22c55e; border-color: #22c55e; color: #000; }

    .slider-group {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .slider-label {
      font-size: 10px;
      color: #555;
      text-transform: uppercase;
      width: 60px;
    }
    input[type="range"] {
      width: 80px;
      height: 3px;
      -webkit-appearance: none;
      background: #333;
      border-radius: 2px;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: #fff;
      border-radius: 50%;
      cursor: pointer;
    }
    .slider-val {
      font-family: monospace;
      font-size: 11px;
      color: #22c55e;
      width: 40px;
    }

    .code-display {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 8px;
      background: #111;
      padding: 6px 12px;
      border-radius: 4px;
      border: 1px solid #222;
    }
    .code-label {
      font-size: 9px;
      color: #555;
      text-transform: uppercase;
    }
    .code-value {
      font-family: monospace;
      font-size: 20px;
      font-weight: bold;
      color: #22c55e;
    }
    .code-arrow {
      color: #333;
      font-size: 16px;
    }

    /* Canvas area */
    .canvas-container {
      flex: 1;
      position: relative;
      overflow: hidden;
    }
    canvas {
      width: 100%;
      height: 100%;
    }

    .info {
      position: absolute;
      bottom: 12px;
      left: 12px;
      font-size: 10px;
      color: #333;
    }
  </style>
</head>
<body>
  <div class="controls">
    <div class="mode-btns">
      <button class="mode-btn active" data-mode="wrench">Wrench</button>
      <button class="mode-btn" data-mode="particles">Particles</button>
      <button class="mode-btn" data-mode="coupled">Coupled</button>
    </div>

    <div class="slider-group">
      <span class="slider-label">Bandwidth</span>
      <input type="range" id="bandwidth" min="0" max="1" step="0.01" value="0.5">
      <span class="slider-val" id="bw-val">1 bit</span>
    </div>

    <div class="slider-group" id="coupling-group" style="display:none;">
      <span class="slider-label">Coupling</span>
      <input type="range" id="coupling" min="0" max="1" step="0.01" value="0.5">
      <span class="slider-val" id="coupling-val">0.50</span>
    </div>

    <div class="slider-group" id="temp-group" style="display:none;">
      <span class="slider-label">Temp</span>
      <input type="range" id="temp" min="1" max="50" step="1" value="20">
      <span class="slider-val" id="temp-val">20</span>
    </div>

    <div class="code-display" id="code-display">
      <div>
        <div class="code-label">Code</div>
        <div class="code-value" id="code-a">A</div>
      </div>
    </div>
  </div>

  <div class="canvas-container">
    <canvas id="canvas"></canvas>
    <div class="info" id="info">Click to perturb</div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    function resize() {
      canvas.width = canvas.clientWidth * devicePixelRatio;
      canvas.height = canvas.clientHeight * devicePixelRatio;
      ctx.scale(devicePixelRatio, devicePixelRatio);
    }
    resize();
    window.addEventListener('resize', resize);

    let mode = 'wrench';
    let bandwidth = 0.5;
    let coupling = 0.5;
    let temperature = 20;

    // ========================================
    // WRENCH - Dzhanibekov effect
    // ========================================
    const Ix = 1.0, Iy = 0.2, Iz = 1.2;
    let wx = 1.0, wy = 0.1, wz = 0.1;

    // Quaternion
    let q = { w: 1, x: 0, y: 0, z: 0 };

    function qMul(a, b) {
      return {
        w: a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z,
        x: a.w*b.x + a.x*b.w + a.y*b.z - a.z*b.y,
        y: a.w*b.y - a.x*b.z + a.y*b.w + a.z*b.x,
        z: a.w*b.z + a.x*b.y - a.y*b.x + a.z*b.w
      };
    }

    function qNorm(q) {
      const m = Math.sqrt(q.w*q.w + q.x*q.x + q.y*q.y + q.z*q.z);
      return { w: q.w/m, x: q.x/m, y: q.y/m, z: q.z/m };
    }

    function qFromAxisAngle(ax, ay, az, angle) {
      const h = angle/2, s = Math.sin(h);
      return qNorm({ w: Math.cos(h), x: ax*s, y: ay*s, z: az*s });
    }

    function qRotVec(q, v) {
      const qv = { w: 0, x: v.x, y: v.y, z: v.z };
      const qc = { w: q.w, x: -q.x, y: -q.y, z: -q.z };
      const r = qMul(qMul(q, qv), qc);
      return { x: r.x, y: r.y, z: r.z };
    }

    function stepWrench() {
      const dt = 0.01;
      for (let i = 0; i < 5; i++) {
        // RK4 for Euler equations
        function derivs(wx, wy, wz) {
          return {
            dwx: (Iy - Iz) * wy * wz / Ix,
            dwy: (Iz - Ix) * wz * wx / Iy,
            dwz: (Ix - Iy) * wx * wy / Iz
          };
        }
        const k1 = derivs(wx, wy, wz);
        const k2 = derivs(wx+k1.dwx*dt/2, wy+k1.dwy*dt/2, wz+k1.dwz*dt/2);
        const k3 = derivs(wx+k2.dwx*dt/2, wy+k2.dwy*dt/2, wz+k2.dwz*dt/2);
        const k4 = derivs(wx+k3.dwx*dt, wy+k3.dwy*dt, wz+k3.dwz*dt);

        wx += (k1.dwx + 2*k2.dwx + 2*k3.dwx + k4.dwx) * dt / 6;
        wy += (k1.dwy + 2*k2.dwy + 2*k3.dwy + k4.dwy) * dt / 6;
        wz += (k1.dwz + 2*k2.dwz + 2*k3.dwz + k4.dwz) * dt / 6;

        // Update quaternion
        const wMag = Math.sqrt(wx*wx + wy*wy + wz*wz);
        if (wMag > 1e-10) {
          const dq = qFromAxisAngle(wx/wMag, wy/wMag, wz/wMag, wMag * dt);
          q = qNorm(qMul(dq, q));
        }
      }
    }

    // Wrench geometry
    const wrenchVerts = [];
    const wrenchEdges = [];
    (function() {
      const hLen = 2.2, hRad = 0.12, tLen = 1.2, tRad = 0.16, seg = 8;
      for (let r = 0; r <= 4; r++) {
        const y = -hLen/2 + (r/4)*hLen;
        for (let i = 0; i < seg; i++) {
          const a = (i/seg) * Math.PI * 2;
          wrenchVerts.push({ x: Math.cos(a)*hRad, y, z: Math.sin(a)*hRad });
        }
      }
      for (let r = 0; r < 4; r++) {
        for (let i = 0; i < seg; i++) {
          wrenchEdges.push([r*seg+i, r*seg+(i+1)%seg]);
          wrenchEdges.push([r*seg+i, (r+1)*seg+i]);
        }
      }
      for (let i = 0; i < seg; i++) wrenchEdges.push([4*seg+i, 4*seg+(i+1)%seg]);

      const hs = wrenchVerts.length, headY = hLen/2;
      for (let r = 0; r <= 3; r++) {
        const x = -tLen/2 + (r/3)*tLen;
        for (let i = 0; i < seg; i++) {
          const a = (i/seg) * Math.PI * 2;
          wrenchVerts.push({ x, y: headY + Math.cos(a)*tRad, z: Math.sin(a)*tRad });
        }
      }
      for (let r = 0; r < 3; r++) {
        for (let i = 0; i < seg; i++) {
          wrenchEdges.push([hs+r*seg+i, hs+r*seg+(i+1)%seg]);
          wrenchEdges.push([hs+r*seg+i, hs+(r+1)*seg+i]);
        }
      }
      for (let i = 0; i < seg; i++) wrenchEdges.push([hs+3*seg+i, hs+3*seg+(i+1)%seg]);
    })();

    function getWrenchCode() {
      const headDir = qRotVec(q, { x: 1, y: 0, z: 0 });
      const state = headDir.z > 0 ? 'A' : 'B';
      const angle = Math.round(Math.atan2(headDir.z, headDir.x) * 180 / Math.PI);

      if (bandwidth < 0.25) return { sym: 'W', color: '#22c55e' };
      if (bandwidth < 0.6) return { sym: state, color: state === 'A' ? '#3b82f6' : '#ef4444' };
      return { sym: angle + '°', color: '#a855f7' };
    }

    function renderWrench() {
      const W = canvas.clientWidth, H = canvas.clientHeight;
      const cx = W/2, cy = H/2;
      const scale = Math.min(W, H) * 0.18;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      const code = getWrenchCode();

      const proj = wrenchVerts.map(v => {
        const r = qRotVec(q, v);
        const persp = 3 / (3 + r.z * 0.3);
        return { x: cx + r.x * persp * scale, y: cy - r.y * persp * scale, z: r.z };
      });

      const sorted = wrenchEdges
        .map(([i, j]) => ({ i, j, z: (proj[i].z + proj[j].z) / 2 }))
        .sort((a, b) => a.z - b.z);

      ctx.lineCap = 'round';
      ctx.lineWidth = 2;
      for (const { i, j, z } of sorted) {
        const alpha = 0.3 + (1 - z / 2) * 0.5;
        ctx.strokeStyle = hexAlpha(code.color, alpha);
        ctx.beginPath();
        ctx.moveTo(proj[i].x, proj[i].y);
        ctx.lineTo(proj[j].x, proj[j].y);
        ctx.stroke();
      }

      document.getElementById('code-a').textContent = code.sym;
      document.getElementById('code-a').style.color = code.color;
    }

    // ========================================
    // PARTICLES - Langevin in double-well
    // ========================================
    const N_PARTICLES = 12;
    let particles = [];
    let particlesB = [];

    function initParticles(arr) {
      arr.length = 0;
      for (let i = 0; i < N_PARTICLES; i++) {
        const side = Math.random() > 0.5 ? 1 : -1;
        arr.push({
          x: side * (20 + Math.random() * 15),
          y: (Math.random() - 0.5) * 40,
          vx: 0, vy: 0
        });
      }
    }
    initParticles(particles);
    initParticles(particlesB);

    function stepParticles(arr, T, bias) {
      bias = bias || 0;
      const wellPos = 30;
      const k = 0.03;
      const gamma = 0.8;
      const dt = 0.5;
      const substeps = 5;

      for (let s = 0; s < substeps; s++) {
        for (const p of arr) {
          // Force toward biased well
          const target = p.x > 0 ? wellPos + bias * 10 : -wellPos + bias * 10;
          const fx = -k * (p.x - target);
          const fy = -0.02 * p.y;

          // Gaussian noise
          const u1 = Math.random(), u2 = Math.random();
          const g1 = Math.sqrt(-2 * Math.log(u1 + 1e-10)) * Math.cos(2 * Math.PI * u2);
          const g2 = Math.sqrt(-2 * Math.log(u1 + 1e-10)) * Math.sin(2 * Math.PI * u2);
          const noise = Math.sqrt(2 * gamma * T * dt / substeps);

          p.vx += (fx - gamma * p.vx) * dt/substeps + noise * g1;
          p.vy += (fy - gamma * p.vy) * dt/substeps + noise * g2;
          p.x += p.vx * dt/substeps;
          p.y += p.vy * dt/substeps;

          // Walls
          if (p.x > 60) { p.x = 60; p.vx *= -0.5; }
          if (p.x < -60) { p.x = -60; p.vx *= -0.5; }
          if (p.y > 40) { p.y = 40; p.vy *= -0.5; }
          if (p.y < -40) { p.y = -40; p.vy *= -0.5; }
        }
      }
    }

    function getParticleCode(arr) {
      let right = 0;
      for (const p of arr) if (p.x > 0) right++;
      return (2 * right - arr.length) / arr.length;
    }

    function quantizeCode(code, bw) {
      if (bw < 0.25) return { sym: '●', color: '#22c55e' };
      if (bw < 0.6) return {
        sym: code > 0 ? 'R' : 'L',
        color: code > 0 ? '#3b82f6' : '#ef4444'
      };
      return {
        sym: Math.round(code * 100) + '%',
        color: code > 0 ? '#3b82f6' : '#ef4444'
      };
    }

    function renderParticles(arr, cx, cy, hue, label) {
      // Background box
      ctx.fillStyle = '#080808';
      ctx.strokeStyle = '#1a1a1a';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.roundRect(cx - 80, cy - 60, 160, 120, 4);
      ctx.fill();
      ctx.stroke();

      // Particles
      for (const p of arr) {
        const px = cx + p.x;
        const py = cy + p.y;
        const particleHue = p.x > 0 ? hue + 30 : hue - 30;
        ctx.fillStyle = `hsla(${particleHue}, 60%, 55%, 0.8)`;
        ctx.beginPath();
        ctx.arc(px, py, 4, 0, Math.PI * 2);
        ctx.fill();
      }

      // Label
      if (label) {
        ctx.fillStyle = '#444';
        ctx.font = '10px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText(label, cx, cy - 70);
      }
    }

    function renderParticleMode() {
      const W = canvas.clientWidth, H = canvas.clientHeight;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      stepParticles(particles, temperature, 0);
      renderParticles(particles, W/2, H/2, 200, null);

      const code = getParticleCode(particles);
      const qCode = quantizeCode(code, bandwidth);
      document.getElementById('code-a').textContent = qCode.sym;
      document.getElementById('code-a').style.color = qCode.color;
    }

    function renderCoupledMode() {
      const W = canvas.clientWidth, H = canvas.clientHeight;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      const codeA = getParticleCode(particles);
      const codeB = getParticleCode(particlesB);

      // Each system is biased by the other's code
      stepParticles(particles, temperature, codeB * coupling);
      stepParticles(particlesB, temperature, codeA * coupling);

      renderParticles(particles, W * 0.3, H/2, 200, 'System A');
      renderParticles(particlesB, W * 0.7, H/2, 30, 'System B');

      // Draw code channel
      ctx.strokeStyle = '#222';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(W * 0.3 + 90, H/2);
      ctx.lineTo(W * 0.7 - 90, H/2);
      ctx.stroke();

      if (coupling > 0.1) {
        ctx.fillStyle = `rgba(100, 200, 100, ${coupling * 0.6})`;
        ctx.font = '12px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('← code →', W/2, H/2 + 4);
      }

      const qA = quantizeCode(codeA, bandwidth);
      const qB = quantizeCode(codeB, bandwidth);

      document.getElementById('code-a').textContent = qA.sym;
      document.getElementById('code-a').style.color = qA.color;

      const codeB_el = document.getElementById('code-b');
      if (codeB_el) {
        codeB_el.textContent = qB.sym;
        codeB_el.style.color = qB.color;
      }
    }

    function hexAlpha(hex, a) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r},${g},${b},${a})`;
    }

    // ========================================
    // MAIN LOOP
    // ========================================
    function loop() {
      if (mode === 'wrench') {
        stepWrench();
        renderWrench();
      } else if (mode === 'particles') {
        renderParticleMode();
      } else if (mode === 'coupled') {
        renderCoupledMode();
      }
      requestAnimationFrame(loop);
    }

    // ========================================
    // CONTROLS
    // ========================================
    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        mode = btn.dataset.mode;

        const couplingGroup = document.getElementById('coupling-group');
        const tempGroup = document.getElementById('temp-group');
        const codeDisplay = document.getElementById('code-display');
        const info = document.getElementById('info');

        if (mode === 'wrench') {
          couplingGroup.style.display = 'none';
          tempGroup.style.display = 'none';
          codeDisplay.innerHTML = '<div><div class="code-label">Code</div><div class="code-value" id="code-a">A</div></div>';
          info.textContent = 'Click to perturb. Dzhanibekov: intermediate axis is unstable.';
          q = { w: 1, x: 0, y: 0, z: 0 };
          wx = 1.0; wy = 0.1; wz = 0.1;
        } else if (mode === 'particles') {
          couplingGroup.style.display = 'none';
          tempGroup.style.display = 'flex';
          codeDisplay.innerHTML = '<div><div class="code-label">Code</div><div class="code-value" id="code-a">●</div></div>';
          info.textContent = 'Particles in double-well. Temperature controls noise.';
          initParticles(particles);
        } else if (mode === 'coupled') {
          couplingGroup.style.display = 'flex';
          tempGroup.style.display = 'flex';
          codeDisplay.innerHTML = `
            <div><div class="code-label">A</div><div class="code-value" id="code-a">●</div></div>
            <span class="code-arrow">⇄</span>
            <div><div class="code-label">B</div><div class="code-value" id="code-b">●</div></div>
          `;
          info.textContent = 'Two systems communicating through codes.';
          initParticles(particles);
          initParticles(particlesB);
        }
      });
    });

    document.getElementById('bandwidth').addEventListener('input', e => {
      bandwidth = parseFloat(e.target.value);
      const labels = ['~0', '1 bit', '∞'];
      document.getElementById('bw-val').textContent = labels[Math.min(2, Math.floor(bandwidth * 3))];
    });

    document.getElementById('coupling').addEventListener('input', e => {
      coupling = parseFloat(e.target.value);
      document.getElementById('coupling-val').textContent = coupling.toFixed(2);
    });

    document.getElementById('temp').addEventListener('input', e => {
      temperature = parseFloat(e.target.value);
      document.getElementById('temp-val').textContent = temperature;
    });

    canvas.addEventListener('click', () => {
      if (mode === 'wrench') {
        wy += (Math.random() - 0.5) * 0.3;
        wz += (Math.random() - 0.5) * 0.3;
      } else {
        for (const p of particles) {
          p.vx += (Math.random() - 0.5) * 10;
          p.vy += (Math.random() - 0.5) * 10;
        }
        if (mode === 'coupled') {
          for (const p of particlesB) {
            p.vx += (Math.random() - 0.5) * 10;
            p.vy += (Math.random() - 0.5) * 10;
          }
        }
      }
    });

    loop();
  </script>
</body>
</html>
