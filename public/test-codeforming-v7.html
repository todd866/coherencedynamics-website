<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Code Formation: Three Modes</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #000;
      color: #e0e0e0;
      min-height: 100vh;
      overflow: hidden;
    }

    .header {
      display: flex;
      gap: 8px;
      padding: 16px 20px;
      border-bottom: 1px solid #1a1a1a;
      background: #050505;
    }

    .mode-btn {
      padding: 8px 16px;
      background: #111;
      border: 1px solid #222;
      border-radius: 6px;
      color: #666;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .mode-btn:hover {
      background: #1a1a1a;
      color: #888;
    }
    .mode-btn.active {
      background: #22c55e;
      border-color: #22c55e;
      color: #000;
    }

    .mode-desc {
      margin-left: auto;
      font-size: 12px;
      color: #444;
      align-self: center;
    }

    .main {
      display: flex;
      height: calc(100vh - 120px);
    }

    canvas {
      flex: 1;
      height: 100%;
    }

    .controls {
      padding: 16px 24px;
      background: #050505;
      border-top: 1px solid #1a1a1a;
      display: flex;
      gap: 32px;
      align-items: center;
    }

    .control-group {
      flex: 1;
      max-width: 400px;
    }

    .control-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #444;
      margin-bottom: 8px;
    }

    .slider-row {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    input[type="range"] {
      flex: 1;
      height: 4px;
      -webkit-appearance: none;
      background: #222;
      border-radius: 2px;
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      background: #fff;
      border-radius: 50%;
      cursor: pointer;
    }

    .value {
      font-family: monospace;
      font-size: 13px;
      min-width: 60px;
      text-align: right;
      color: #22c55e;
    }

    .code-display {
      display: flex;
      gap: 16px;
      align-items: center;
    }

    .code-box {
      background: #0a0a0a;
      border-radius: 6px;
      padding: 8px 16px;
      text-align: center;
      min-width: 80px;
    }

    .code-box-label {
      font-size: 9px;
      color: #444;
      margin-bottom: 4px;
    }

    .code-value {
      font-family: monospace;
      font-size: 24px;
      font-weight: bold;
    }

    .arrow {
      font-size: 20px;
      color: #333;
    }
  </style>
</head>
<body>
  <div class="header">
    <button class="mode-btn active" data-mode="passive">Passive (Wrench)</button>
    <button class="mode-btn" data-mode="constrained">Self-Constrained</button>
    <button class="mode-btn" data-mode="coupled">Coupled Systems</button>
    <div class="mode-desc" id="mode-desc">Code reflects dynamics, no feedback</div>
  </div>

  <div class="main">
    <canvas id="canvas"></canvas>
  </div>

  <div class="controls">
    <div class="control-group">
      <div class="control-label">Code Channel Bandwidth</div>
      <div class="slider-row">
        <span style="color: #444; font-size: 10px;">0</span>
        <input type="range" id="bandwidth" min="0" max="1" step="0.01" value="0.5">
        <span style="color: #444; font-size: 10px;">∞</span>
        <span class="value" id="bw-value">1 bit</span>
      </div>
    </div>

    <div class="control-group" id="coupling-control" style="display: none;">
      <div class="control-label">Code-Dynamics Coupling</div>
      <div class="slider-row">
        <span style="color: #444; font-size: 10px;">0</span>
        <input type="range" id="coupling" min="0" max="1" step="0.01" value="0.5">
        <span style="color: #444; font-size: 10px;">1</span>
        <span class="value" id="coupling-value">0.50</span>
      </div>
    </div>

    <div class="code-display" id="code-display">
      <div class="code-box">
        <div class="code-box-label">CODE</div>
        <div class="code-value" id="code-a">A</div>
      </div>
    </div>
  </div>

  <script>
    // ==========================================================================
    // SETUP
    // ==========================================================================

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    function resize() {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // ==========================================================================
    // STATE
    // ==========================================================================

    let mode = 'passive'; // passive, constrained, coupled
    let bandwidth = 0.5;
    let coupling = 0.5;

    // ==========================================================================
    // QUATERNION
    // ==========================================================================

    const quat = {
      mul: (a, b) => ({
        w: a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z,
        x: a.w*b.x + a.x*b.w + a.y*b.z - a.z*b.y,
        y: a.w*b.y - a.x*b.z + a.y*b.w + a.z*b.x,
        z: a.w*b.z + a.x*b.y - a.y*b.x + a.z*b.w
      }),
      normalize: (q) => {
        const m = Math.sqrt(q.w*q.w + q.x*q.x + q.y*q.y + q.z*q.z);
        return { w: q.w/m, x: q.x/m, y: q.y/m, z: q.z/m };
      },
      fromAxisAngle: (ax, ay, az, angle) => {
        const h = angle/2, s = Math.sin(h);
        return quat.normalize({ w: Math.cos(h), x: ax*s, y: ay*s, z: az*s });
      },
      rotateVec: (q, v) => {
        const qv = { w: 0, ...v };
        const qc = { w: q.w, x: -q.x, y: -q.y, z: -q.z };
        const r = quat.mul(quat.mul(q, qv), qc);
        return { x: r.x, y: r.y, z: r.z };
      }
    };

    // ==========================================================================
    // WRENCH (for passive mode)
    // ==========================================================================

    function generateWrench() {
      const verts = [], edges = [];
      const hLen = 2, hRad = 0.11, tLen = 1, tRad = 0.14, seg = 8;

      for (let r = 0; r <= 4; r++) {
        const y = -hLen/2 + (r/4)*hLen;
        for (let i = 0; i < seg; i++) {
          const a = (i/seg) * Math.PI * 2;
          verts.push({ x: Math.cos(a)*hRad, y, z: Math.sin(a)*hRad });
        }
      }
      for (let r = 0; r < 4; r++) {
        for (let i = 0; i < seg; i++) {
          edges.push([r*seg+i, r*seg+(i+1)%seg]);
          edges.push([r*seg+i, (r+1)*seg+i]);
        }
      }
      for (let i = 0; i < seg; i++) edges.push([4*seg+i, 4*seg+(i+1)%seg]);

      const hs = verts.length, headY = hLen/2;
      for (let r = 0; r <= 3; r++) {
        const x = -tLen/2 + (r/3)*tLen;
        for (let i = 0; i < seg; i++) {
          const a = (i/seg) * Math.PI * 2;
          verts.push({ x, y: headY + Math.cos(a)*tRad, z: Math.sin(a)*tRad });
        }
      }
      for (let r = 0; r < 3; r++) {
        for (let i = 0; i < seg; i++) {
          edges.push([hs+r*seg+i, hs+r*seg+(i+1)%seg]);
          edges.push([hs+r*seg+i, hs+(r+1)*seg+i]);
        }
      }
      for (let i = 0; i < seg; i++) edges.push([hs+3*seg+i, hs+3*seg+(i+1)%seg]);

      return { verts, edges };
    }

    const wrench = generateWrench();

    // Wrench physics
    const I1 = 0.2, I2 = 1.0, I3 = 1.2;
    let wrenchState = {
      q: quat.normalize({ w: 1, x: 0.1, y: 0.05, z: 0 }),
      ox: 0.003, oy: 0.05, oz: 0.004
    };

    function stepWrench() {
      const { ox, oy, oz } = wrenchState;
      const dox = (I2-I3)*oy*oz/I1;
      const doy = (I3-I1)*oz*ox/I2;
      const doz = (I1-I2)*ox*oy/I3;

      wrenchState.ox = (wrenchState.ox + dox) * 0.9999;
      wrenchState.oy = (wrenchState.oy + doy) * 0.9999;
      wrenchState.oz = (wrenchState.oz + doz) * 0.9999;

      const om = Math.sqrt(wrenchState.ox**2 + wrenchState.oy**2 + wrenchState.oz**2);
      if (om > 1e-10) {
        const dq = quat.fromAxisAngle(wrenchState.ox/om, wrenchState.oy/om, wrenchState.oz/om, om);
        wrenchState.q = quat.normalize(quat.mul(wrenchState.q, dq));
      }
    }

    function getWrenchCode() {
      const head = quat.rotateVec(wrenchState.q, { x: 1, y: 0, z: 0 });
      const state = head.z > 0 ? 'A' : 'B';
      const angle = Math.atan2(head.z, head.x) * 180 / Math.PI;

      if (bandwidth < 0.3) return { sym: 'W', color: '#22c55e' };
      if (bandwidth < 0.6) return { sym: state, color: state === 'A' ? '#3b82f6' : '#ef4444' };
      return { sym: Math.round(angle/10)*10 + '°', color: '#a855f7' };
    }

    // ==========================================================================
    // PARTICLE SYSTEM (for constrained and coupled modes)
    // ==========================================================================

    class ParticleSystem {
      constructor(id, x, y, hue) {
        this.id = id;
        this.centerX = x;
        this.centerY = y;
        this.hue = hue;
        this.particles = [];
        this.code = 0; // -1 to 1, continuous internal state
        this.codeOutput = 'L'; // quantized output
        this.potentialBias = 0; // external influence on potential

        // Create particles
        for (let i = 0; i < 40; i++) {
          this.particles.push({
            x: (Math.random() - 0.5) * 150,
            y: (Math.random() - 0.5) * 150,
            vx: (Math.random() - 0.5) * 2,
            vy: (Math.random() - 0.5) * 2
          });
        }
      }

      step(couplingStrength, externalCode) {
        const bias = this.potentialBias + (externalCode || 0) * couplingStrength * 0.5;

        for (const p of this.particles) {
          // Potential well with bias
          // Base potential: double-well along X axis
          // bias shifts which well is deeper
          const wellCenter = bias * 60;
          const fx = -0.02 * (p.x - wellCenter);
          const fy = -0.015 * p.y;

          // Add some noise
          const noise = 0.3;
          p.vx += fx + (Math.random() - 0.5) * noise;
          p.vy += fy + (Math.random() - 0.5) * noise;

          // Damping
          p.vx *= 0.98;
          p.vy *= 0.98;

          // Integrate
          p.x += p.vx;
          p.y += p.vy;

          // Soft boundaries
          if (Math.abs(p.x) > 120) p.vx -= Math.sign(p.x) * 0.5;
          if (Math.abs(p.y) > 80) p.vy -= Math.sign(p.y) * 0.5;
        }

        // Compute code from particle distribution
        let leftCount = 0, rightCount = 0;
        for (const p of this.particles) {
          if (p.x < 0) leftCount++;
          else rightCount++;
        }
        this.code = (rightCount - leftCount) / this.particles.length;

        // Quantize to output symbol based on bandwidth
        this.codeOutput = this.quantizeCode();

        // Self-constraint: code feeds back to potential bias
        if (mode === 'constrained' || mode === 'coupled') {
          const feedbackStrength = coupling * 0.8;
          const targetBias = this.code > 0 ? 0.5 : -0.5;
          this.potentialBias += (targetBias - this.potentialBias) * feedbackStrength * 0.02;
        }
      }

      quantizeCode() {
        if (bandwidth < 0.2) return '•';
        if (bandwidth < 0.5) return this.code > 0 ? 'R' : 'L';
        if (bandwidth < 0.8) {
          if (this.code > 0.3) return 'R+';
          if (this.code > 0) return 'R-';
          if (this.code > -0.3) return 'L-';
          return 'L+';
        }
        return (this.code * 100).toFixed(0) + '%';
      }

      draw(ctx) {
        const cx = this.centerX;
        const cy = this.centerY;

        // Draw potential well visualization
        ctx.strokeStyle = `hsla(${this.hue}, 50%, 30%, 0.3)`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let x = -120; x <= 120; x += 5) {
          const bias = this.potentialBias * 60;
          const potential = 0.0001 * (x - bias) ** 2;
          const y = cy + 60 - potential * 0.5;
          if (x === -120) ctx.moveTo(cx + x, y);
          else ctx.lineTo(cx + x, y);
        }
        ctx.stroke();

        // Draw particles
        for (const p of this.particles) {
          const screenX = cx + p.x;
          const screenY = cy + p.y;

          // Color based on position (left=one color, right=another)
          const t = (p.x + 120) / 240;
          const hue = this.hue + (p.x > 0 ? 30 : -30);

          ctx.fillStyle = `hsla(${hue}, 70%, 60%, 0.7)`;
          ctx.beginPath();
          ctx.arc(screenX, screenY, 4, 0, Math.PI * 2);
          ctx.fill();
        }

        // Draw code output
        const codeColor = this.code > 0
          ? `hsl(${this.hue + 30}, 70%, 60%)`
          : `hsl(${this.hue - 30}, 70%, 60%)`;

        ctx.fillStyle = codeColor;
        ctx.font = 'bold 32px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(this.codeOutput, cx, cy + 100);

        ctx.fillStyle = '#444';
        ctx.font = '11px system-ui';
        ctx.fillText(`System ${this.id}`, cx, cy - 90);
      }
    }

    let systemA = new ParticleSystem('A', 0, 0, 200);
    let systemB = new ParticleSystem('B', 0, 0, 30);

    // ==========================================================================
    // RENDERING
    // ==========================================================================

    function renderPassive() {
      const W = canvas.width, H = canvas.height;
      const cx = W/2, cy = H/2;
      const scale = Math.min(W, H) * 0.2;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      // Project wrench
      const code = getWrenchCode();
      const proj = wrench.verts.map(v => {
        const r = quat.rotateVec(wrenchState.q, v);
        const s = 4 / (4 + r.z * 0.4 + 2);
        return { x: cx + r.x*s*scale, y: cy - r.y*s*scale, z: r.z };
      });

      const sorted = wrench.edges
        .map(([i,j]) => ({ i, j, z: (proj[i].z + proj[j].z)/2 }))
        .sort((a,b) => b.z - a.z);

      ctx.lineCap = 'round';
      ctx.lineWidth = 1.5;
      for (const {i, j} of sorted) {
        const a = 0.3 + (1 - (proj[i].z + proj[j].z)/4) * 0.5;
        ctx.strokeStyle = hexAlpha(code.color, a);
        ctx.beginPath();
        ctx.moveTo(proj[i].x, proj[i].y);
        ctx.lineTo(proj[j].x, proj[j].y);
        ctx.stroke();
      }

      // Update code display
      document.getElementById('code-a').textContent = code.sym;
      document.getElementById('code-a').style.color = code.color;
    }

    function renderConstrained() {
      const W = canvas.width, H = canvas.height;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      systemA.centerX = W/2;
      systemA.centerY = H/2 - 20;
      systemA.draw(ctx);

      // Draw feedback arrow
      if (coupling > 0.1) {
        ctx.strokeStyle = `rgba(100, 200, 100, ${coupling * 0.5})`;
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.arc(W/2, H/2, 130, 0.5, 2.5);
        ctx.stroke();
        ctx.setLineDash([]);

        // Arrow head
        ctx.fillStyle = `rgba(100, 200, 100, ${coupling * 0.5})`;
        ctx.beginPath();
        ctx.moveTo(W/2 - 100, H/2 - 60);
        ctx.lineTo(W/2 - 90, H/2 - 75);
        ctx.lineTo(W/2 - 85, H/2 - 55);
        ctx.fill();
      }

      // Update display
      document.getElementById('code-a').textContent = systemA.codeOutput;
      document.getElementById('code-a').style.color = systemA.code > 0 ? '#60a5fa' : '#f87171';
    }

    function renderCoupled() {
      const W = canvas.width, H = canvas.height;

      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      systemA.centerX = W * 0.28;
      systemA.centerY = H/2 - 20;
      systemB.centerX = W * 0.72;
      systemB.centerY = H/2 - 20;

      systemA.draw(ctx);
      systemB.draw(ctx);

      // Draw code channel between systems
      const chanY = H/2 + 100;
      const chanX1 = W * 0.35;
      const chanX2 = W * 0.65;

      // Channel pipe
      ctx.fillStyle = '#111';
      ctx.fillRect(chanX1, chanY - 15, chanX2 - chanX1, 30);
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.strokeRect(chanX1, chanY - 15, chanX2 - chanX1, 30);

      // Bandwidth indicator
      const bwWidth = (chanX2 - chanX1 - 20) * bandwidth;
      ctx.fillStyle = '#22c55e33';
      ctx.fillRect(chanX1 + 10, chanY - 10, bwWidth, 20);

      // Arrows showing communication
      if (coupling > 0.1) {
        ctx.fillStyle = `rgba(100, 200, 100, ${coupling * 0.6})`;
        ctx.font = '16px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('← code →', W/2, chanY + 5);
      }

      // Labels
      ctx.fillStyle = '#444';
      ctx.font = '10px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('CODE CHANNEL', W/2, chanY + 30);

      // Update display
      document.getElementById('code-a').textContent = systemA.codeOutput;
      document.getElementById('code-a').style.color = systemA.code > 0 ? '#60a5fa' : '#f87171';

      const codeB = document.getElementById('code-b');
      if (codeB) {
        codeB.textContent = systemB.codeOutput;
        codeB.style.color = systemB.code > 0 ? '#fbbf24' : '#fb923c';
      }
    }

    function hexAlpha(hex, a) {
      if (hex.startsWith('rgb')) return hex.replace(')', `, ${a})`).replace('rgb', 'rgba');
      const r = parseInt(hex.slice(1,3), 16);
      const g = parseInt(hex.slice(3,5), 16);
      const b = parseInt(hex.slice(5,7), 16);
      return `rgba(${r},${g},${b},${a})`;
    }

    // ==========================================================================
    // MAIN LOOP
    // ==========================================================================

    function loop() {
      if (mode === 'passive') {
        stepWrench();
        renderPassive();
      } else if (mode === 'constrained') {
        systemA.step(coupling, 0);
        renderConstrained();
      } else if (mode === 'coupled') {
        // Systems influence each other through their codes
        const codeFromA = systemA.code;
        const codeFromB = systemB.code;
        systemA.step(coupling, codeFromB);
        systemB.step(coupling, codeFromA);
        renderCoupled();
      }

      requestAnimationFrame(loop);
    }

    // ==========================================================================
    // CONTROLS
    // ==========================================================================

    document.querySelectorAll('.mode-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        mode = btn.dataset.mode;

        // Update UI
        const couplingControl = document.getElementById('coupling-control');
        const codeDisplay = document.getElementById('code-display');
        const modeDesc = document.getElementById('mode-desc');

        if (mode === 'passive') {
          couplingControl.style.display = 'none';
          codeDisplay.innerHTML = `
            <div class="code-box">
              <div class="code-box-label">CODE</div>
              <div class="code-value" id="code-a">A</div>
            </div>`;
          modeDesc.textContent = 'Code reflects dynamics, no feedback';
        } else if (mode === 'constrained') {
          couplingControl.style.display = 'block';
          codeDisplay.innerHTML = `
            <div class="code-box">
              <div class="code-box-label">CODE</div>
              <div class="code-value" id="code-a">L</div>
            </div>
            <div class="arrow">↺</div>`;
          modeDesc.textContent = 'Code feeds back to constrain dynamics';
          // Reset system
          systemA = new ParticleSystem('A', 0, 0, 200);
        } else if (mode === 'coupled') {
          couplingControl.style.display = 'block';
          codeDisplay.innerHTML = `
            <div class="code-box">
              <div class="code-box-label">SYSTEM A</div>
              <div class="code-value" id="code-a">L</div>
            </div>
            <div class="arrow">⇄</div>
            <div class="code-box">
              <div class="code-box-label">SYSTEM B</div>
              <div class="code-value" id="code-b">R</div>
            </div>`;
          modeDesc.textContent = 'Two systems communicate through codes';
          // Reset systems
          systemA = new ParticleSystem('A', 0, 0, 200);
          systemB = new ParticleSystem('B', 0, 0, 30);
        }
      });
    });

    document.getElementById('bandwidth').addEventListener('input', (e) => {
      bandwidth = parseFloat(e.target.value);
      let label;
      if (bandwidth < 0.2) label = '~0 bits';
      else if (bandwidth < 0.5) label = '1 bit';
      else if (bandwidth < 0.8) label = '2 bits';
      else label = '∞ bits';
      document.getElementById('bw-value').textContent = label;
    });

    document.getElementById('coupling').addEventListener('input', (e) => {
      coupling = parseFloat(e.target.value);
      document.getElementById('coupling-value').textContent = coupling.toFixed(2);
    });

    canvas.addEventListener('click', (e) => {
      if (mode === 'passive') {
        wrenchState.ox += (Math.random() - 0.5) * 0.03;
        wrenchState.oy += (Math.random() - 0.5) * 0.03;
        wrenchState.oz += (Math.random() - 0.5) * 0.03;
      } else {
        // Add energy to particles
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const sys = (mode === 'coupled' && x > canvas.width / 2) ? systemB : systemA;
        for (const p of sys.particles) {
          p.vx += (Math.random() - 0.5) * 5;
          p.vy += (Math.random() - 0.5) * 5;
        }
      }
    });

    // Start
    loop();
  </script>
</body>
</html>
